[package]
name = "blog_os"
version = "0.1.0"
edition = "2021"
authors = ["Au Or <au.or@github.com>"]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

# le profile utilisé pour `cargo build`
#[profile.dev]
#panic = "abort" # désactive le déroulement de la pile lors d'un panic

# le profile utilisé pour `cargo build --release`
#[profile.release]
#panic = "abort" # désactive le déroulement de la pile lors d'un panic

#Au lieu d'écrire notre propre bootloader, qui est un projet en soi, nous utilisons le bootloadercrate. Cette caisse implémente un chargeur de démarrage BIOS de base sans aucune dépendance C, juste Rust et assemblage en ligne
[dependencies]
bootloader = "0.9.8"
#le compilateur peut décider que nos ecritures avec nos fonctions et le tampon vga sont inutiles et peuvent être omises
#Afin d'utiliser les écritures volatiles pour le tampon VGA, nous utilisons la bibliothèque volatile . Cette caisse (c'est ainsi que les packages sont appelés dans le monde Rust) fournit un Volatiletype de wrapper avec readet des writeméthodes. Ces méthodes utilisent en interne les fonctions read_volatile et write_volatile de la bibliothèque principale et garantissent ainsi que les lectures/écritures ne sont pas optimisées.
volatile = "0.2.6"
#Pour obtenir une mutabilité intérieure synchronisée, les utilisateurs de la bibliothèque standard peuvent utiliser Mutex .
#Il fournit une exclusion mutuelle en bloquant les threads lorsque la ressource est déjà verrouillée. Mais notre noyau de base n'a pas de support de blocage ni même de concept de threads, nous ne pouvons donc pas l'utiliser non plus.
# le spinlock . Au lieu de bloquer, les threads essaient simplement de le verrouiller encore et encore dans une boucle serrée et donc de brûler du temps CPU jusqu'à ce que le mutex soit à nouveau libre.
spin = "0.5.2"
#pour les entrees sorties avec isa-debug etc. etc. 
x86_64 = "0.14.2"

[dependencies.lazy_static]
version = "1.0"
features = ["spin_no_std"]

#nous avons une boucle sans fin à la fin de notre _startfonction et devons fermer QEMU manuellement à chaque exécution de cargo test
#il y a une trappe d'évacuation : QEMU prend en charge un isa-debug-exitdispositif spécial, qui fournit un moyen facile de quitter QEMU du système invité. Pour l'activer, nous devons passer un -deviceargument à QEMU. Nous pouvons le faire en ajoutant une package.metadata.bootimage.test-argsclé de configuration dans notre Cargo.toml
[package.metadata.bootimage]

#en quittant qemu apres les tests, meme s'ils ont reussi cargo considere tout les codes de sortie differents de 0 comme des erreurs
#Pour contourner ce problème, bootimagefournit une test-success-exit-codeclé de configuration qui mappe un code de sortie spécifié au code de sortie 0
#Avec cette configuration, bootimagemappe notre code de sortie de réussite sur le code de sortie 0, de sorte qu'il cargo testreconnaisse correctement le cas de réussite et ne compte pas le test comme ayant échoué.
test-args = [
    "-device", "isa-debug-exit,iobase=0xf4,iosize=0x04", "-serial", "stdio",
    "-display", "none"
]
test-success-exit-code = 33         # (0x10 << 1) | 1
